---
title: 'TV Show and Movie Popularity Analysis'
author:
  - Christian Garduno
  - Roshan Mehta
  - Colton Rowe
date: "6/3/23"
theme:
  dark: darkly
format:
  html:
    page-layout: full
    toc: true
    code-fold: true
editor: visual
jupyter: python3
---

::: panel-tabset
#### Home

**Abstract**

The present article analyzes a dataset containing information about streaming titles, specifically focusing on TV shows and movies from four popular streaming platforms. The dataset, which can be found [here](../Data%20Preprocessing.qmd), provides valuable insights into the popularity and characteristics of different titles available on the streaming platform.

**Problem Statement**

The streaming services industry has seen rapid growth in recent years and has undoubtedly revolutionized the way we consume content. With numerous platforms offering a vast array of TV shows, it has become increasingly important for creators and streaming platforms to understand what makes a TV show popular. Here, we aim to explore and uncover key factors that contribute to the popularity of TV shows on streaming platforms through a series of different models.

**Data Collection and Description**

*Variable Description*

The dataset contains both categorical and numeric variables which may provide insights for our analysis. Here is a brief description of the key variables:

-   **`type`**: Indicates whether the show is a TV series or a movie.
-   **`title`**: The title of the TV show.
-   **`director`**: The name of the director(s) of the show.
-   **`cast`**: The names of the main cast members.
-   **`country`**: The countries the show was released in.
-   **`release_year`**: The year when the show was released.
-   **`rating`**: The content rating assigned to the show (TV-14, PG-13, etc.).
-   **`duration`**: The number of seasons (for TV series) or the duration (minutes) of the movie (for movies).
-   **`listed_in`**: The genre(s) or category(s) the show belongs to.
-   **`description`**: A brief summary or description of the show.
-   **`score`**: Rating of the show or movie - scraped from IMDB.
-   **`director_score`**: Calculated score based on the directors of the title.

Together, these variables provide a set of features that allow us to analyze and understand the characteristics that determine the popularity of TV shows. By exploring these variables and their relationships, we can gain insights into the factors that contribute to a show's popularity, like the impact of different genres or countries of origin, and begin to create better shows that more people would watch.

#### Data

**Source**

We combined four datasets found on kaggle to get a comprehensive dataset of movies and TV shows.

[Disney+](https://www.kaggle.com/datasets/shivamb/disney-movies-and-tv-shows)

[Hulu](https://www.kaggle.com/datasets/shivamb/hulu-movies-and-tv-shows)

[Amazon Prime](https://www.kaggle.com/datasets/shivamb/amazon-prime-movies-and-tv-shows)

[Netflix](https://www.kaggle.com/datasets/shivamb/netflix-shows)

**Cleaning**
 How to address nulls? 

**Train Split**
talk to colton

#### EDA

In this section we will explore and visualize our dataset to gain a better understanding of what we are working with, identify any obvious patterns, correlations, or trends.

TODO: Add description
/ interpretation for each figure

```{python}
import pandas as pd
data = pd.read_csv("../Data/data/streaming_titles_final.csv")
```

## Figures

::: panel-tabset

```{python}
# | echo: False
import matplotlib.pyplot as plt
```

#### needs title
```{python}
import seaborn as sns
sns.countplot(x=data["type"])
```

#### needs title
```{python}
# | fig.width: 10
# 1. Line Chart of the Number of Titles Released per Year

# Group data by year and count number of titles
counts = data.groupby("release_year")["title"].count()

# Create line chart
#plt.figure(figsize=(10,10))
plt.plot(counts.index, counts.values)

# Add labels and title
plt.xlabel("Year")
plt.ylabel("Number of Titles Released")
plt.title("Number of Titles Released per Year")

# Display chart
plt.show()
```

#### needs title
```{python}
# | fig.width: 10

# 2. Histogram of the Distribution of Content Ratings

# Create histogram of content ratings
#plt.figure(figsize=(20,10))
plt.hist(data["rating"].dropna(), bins=10)

# Add labels and title
plt.xlabel("Content Rating")
plt.xticks(rotation=45)
plt.ylabel("Frequency")
plt.title("Distribution of Content Ratings")

# Display chart
plt.show()
```

#### needs title
```{python}
# | fig.width: 10

# 3. Bar Chart of the Number of Titles per Country (count > 10)

# Extract first country from country column
chart = data.copy()
chart["country"] = chart["country"].str.split(", ").str[0]

# Group data by country and count number of titles
counts = chart.groupby("country")["title"].count()
counts = counts[counts > 10].sort_values(ascending=False)

# Create bar chart
#plt.figure(figsize=(20,10))
plt.bar(counts.index, counts.values)

# Add labels and title
plt.xlabel("Country")
plt.xticks(rotation=90)
plt.ylabel("Number of Titles")
plt.title("Number of Titles per Country")

# Display chart
plt.show()
```

#### needs title
```{python}
# | fig.width: 10

# 4. Movie and Rating Scatter Plot

# Filter out TV shows and missing ratings
movies = data[(data["type"] == "Movie") & (data["score"].notnull())]

# Create scatter plot of IMDB rating vs. runtime
#plt.figure(figsize=(20,10))
plt.scatter(movies["score"], movies["duration"], alpha=0.5)

# Add labels and title
plt.xlabel("IMDB Rating")
plt.ylabel("Runtime (minutes)")
plt.title("IMDB Rating vs. Runtime for Movies on Streaming Services")

# Display chart
plt.show()
```

#### needs title
```{python}
# | fig.width: 10

# 5. TV Show and Rating Scatter Plot

# Filter out Movies and missing ratings
tv = data[(data["type"] == "TV Show") & (data["score"].notnull())]

# Create scatter plot of IMDB rating vs. runtime
#plt.figure(figsize=(20,10))
plt.scatter(tv["score"], tv["duration"], alpha=0.5)

# Add labels and title
plt.xlabel("IMDB Rating")
plt.ylabel("Runtime (seasons)")
plt.title("IMDB Rating vs. Runtime for Movies on Streaming Services")

# Display chart
plt.show()
```

#### needs title
```{python}
# | fig.width: 10

# 6. Top 15 Genres By Number of Titles

# Get list of genre columns
genre_cols = [col for col in data.columns if col.startswith("genre")]

# Sum the number of true values in each genre column to get the total number of titles for each genre
genre_counts = data[genre_cols].sum()#.sort_values(ascending=False)

# Get the top 10 genres by number of titles
top_genres = genre_counts[:15]

# Remove "genre." from the genre names in the x-axis labels
labels = [col.replace("genre.", "") for col in top_genres.index]

# Create bar chart
# plt.figure(figsize=(20, 10))
plt.bar(labels, top_genres.values, color='purple')

# Add labels and title
plt.xlabel("Genre")
plt.xticks(rotation=45, ha='right')
plt.ylabel("Number of Titles")
plt.title("Top 10 Genres by Number of Titles")

# Display chart
plt.show()
```
:::

Also need to go back and figure out how to show only the charts and hide the other unnecessary output.

```{python}
import matplotlib.pyplot as plt

data = data

print("The number of rows in the data set is " + str(len(data)))
data.head()
```

```{python}
data.isna().sum(); print(data.shape)
```

#### App

Here, you can input parameters for a Movie or TV Show and see our model's prediction for your show.

<iframe
  src="https://tv-popularity-model.streamlit.app//?embed=true"
  height="750"
  style="width:100%;border:none;"
></iframe>

#### Methods

```{python}
# | echo: false
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(os.path.abspath("__file__")), '../Modeling')))
import ModelHelpers
import joblib
import sklearn
```

# Modeling

::: panel-tabset
#### Beta Regression

## Beta Regression

- Similar to a logistic regression, it uses a sigmoid to predict a probability in [0,1].
- The response can be scaled to a specified range ([0,100]).
- It's hyperparameter is scale.

![Sigmoid](Images/sigmoid.png)

We decided to fit a beta regression as opposed to a linear regression because we wanted the model to predict values only within the range [0,100]. A beta regression allows us to specify this range.

Our pipeline was structured as follows:

```{python}
# | echo : False
joblib.load("../Modeling/models/beta_regression.joblib")
```

First, we selected the predictors we wanted to use. Then, we one hot encoded the categorical variables. Simultaneously, we dealt with missing numerical values by encoding if a value was missing and filling it with a 0 if it was. We add our model as the last step in the pipeline.

We tuned the hyperparameter scale, and found that a scale of 1 was the best to use. The best cross-evaluation score for this model was a mean squared error of 19.26. We can loosely interpret this as saying our model is, on average, 19.26 imdb rating points off from the actual score.

#### KNN

## K-Nearest Neigbors

- bullets

```{python}
# | echo : False
joblib.load("../Modeling/models/knn.joblib")
```

#### Decision Tree

## Decision Tree Regressor

- A series of yes/no questions
- Questions start general and become more specific
- Leaf nodes represent the predicted score
- Will never predict greater than the maximum value or less than the minimum value

```{python}
# | echo : False
joblib.load("../Modeling/models/decision_tree.joblib")
```

#### Random Forest

## Random Forest Regressor

- Many decision trees working together
- Each tree has a restricted set of parameters

```{python}
# | echo : False
joblib.load("../Modeling/models/random_forest.joblib")
```

:::

# Results

TODO: Take Beta Regression and Random Forest and calculate test MSE. Compare with standard deviation, make inferences.



:::
